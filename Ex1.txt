
// Funções g2

a = split p1 ((map p1) . p2)
b = discollect . singleton
c = map (uncurry (++))
d = c . b . a
e = (map p2) . p2
f = split d e
g = uncurry zip
h = g . f
i = h . (id >< concat)

// Testar

g1 = singleton . split nil id
g2 = uncurry zip . split ((map (uncurry (++))) . discollect . singleton . split p1 ((map p1) . p2)) ((map p2) . p2) . (id >< concat)
g = either g1 g2
tar = cataExp g
dic_exp = collect.tar
dicio = dic_imp d 
dic_exp dicio

// Demonstrações

h ("A",[("S","AT"),("SA","WING")]) = [("AS","AT"),("ASA","WING")]

        f ("A",[("S","AT"),("SA","WING")]) = (["AS","ASA"],["AT","WING"])

                d ("A",[("S","AT"),("SA","WING")]) = ["AS","ASA"]

                        a ("A",[("S","AT"),("SA","WING")]) = ("A",["S","SA"])

                        b ("A",["S","SA"]) = [("A","S"),("A","SA")]

                        c [("A","S"),("A","SA")] = ["AS","ASA"]

                e ("A",[("S","AT"),("SA","WING")]) = ["AT","WING"]

        g (["AS","ASA"],["AT","WING"]) = [("AS","AT"),("ASA","WING")]




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



a = (split p1 (singl . p2) ) >< dic_exp

b = singl >< id

c = dic_imp . (sortBy compare) . conc . b . a











b = id >< (split head tail) 

c = Cp.cond (< (p1 . p1) (p1 . p2)) () ()

c = Cp.cond ((<) p1 p2) (conc p1 p2) (conc p2 p1)